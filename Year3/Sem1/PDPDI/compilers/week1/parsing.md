# Parsers

### Problem
- A language is a collection of strings drawn from an alphabet
- Its syntax can be specified by grammar rules

**Goal:** a parser processes a string of tokens, and verifies that the string can be generated from the grammar rules of the language

### Context-Free Grammars
Programming languages are typically specified using CFGs 
Formally, they can be defined as follows:
$$G= \ <N,T,P,S>$$
where:
- $N$: a set of non-terminal symbols
- $T$: a set of terminal symbols
- $P$: a set of production rules
- $S$: a start non-terminal symbol

The terminal and non-terminal symbols are tokens generated by the lexer.

![[Pasted image 20241114163947.png]]

#### Derivations
A derivation is a sequence of steps of the form
$$\alpha A \beta \Rightarrow \alpha something \beta$$
![[Pasted image 20241114173129.png]]

basically mlfcs part 2: electric boogaloo
#### Parse Trees
Derivations can also be represented as parse trees, that filter out the order in which productions are applied to replace non-terminals
![[Pasted image 20241114173232.png]]

##### Concrete vs Abstract Syntax Trees
![[Pasted image 20241114173305.png]]
Parsers will build ASTs

a